<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Pixely ‚Äì Pixel-Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- GIF.js f√ºr animierte GIF-Erstellung -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --border: #1f2937;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 1.5rem;
    }

    .app {
      max-width: 1100px;
      width: 100%;
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: 0 25px 60px rgba(15, 23, 42, 0.8);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0;
    }

    .logo-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, #22c55e, #38bdf8);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.8);
    }

    .header-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }

    main {
      display: grid;
      grid-template-columns: minmax(230px, 320px) minmax(0, 1fr);
      gap: 0;
      min-height: 460px;
      max-height: 80vh;
    }

    @media (max-width: 840px) {
      main {
        grid-template-columns: 1fr;
        max-height: none;
      }
    }

    .sidebar {
      border-right: 1px solid var(--border);
      padding: 0.8rem 1rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      background: #020617;
    }

    @media (max-width: 840px) {
      .sidebar {
        border-right: none;
        border-bottom: 1px solid var(--border);
      }
    }

    .section {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      align-items: center;
    }

    label {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    select,
    input[type="number"],
    input[type="range"] {
      background: #020617;
      border-radius: 0.4rem;
      border: 1px solid #111827;
      padding: 0.3rem 0.45rem;
      font-size: 0.8rem;
      color: #e5e7eb;
      outline: none;
      min-width: 0;
    }

    select:focus,
    input[type="number"]:focus,
    input[type="range"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    input[type="range"] {
      flex: 1;
    }

    input[type="color"] {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      padding: 0;
      width: 2.1rem;
      height: 2.1rem;
      border-radius: 0.6rem;
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 0 0 1px #111827, 0 0 0 3px #020617;
    }

    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: none; }

    .btn {
      border-radius: 999px;
      border: 1px solid #111827;
      background: #020617;
      font-size: 0.8rem;
      padding: 0.3rem 0.75rem;
      color: #e5e7eb;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      cursor: pointer;
      outline: none;
      white-space: nowrap;
      transition: background 0.12s ease, border-color 0.12s ease, transform 0.06s ease;
    }

    .btn:hover {
      background: #030712;
      transform: translateY(-0.5px);
    }

    .btn-primary {
      border-color: var(--accent);
      background: radial-gradient(circle at top left, #0ea5e9, #0369a1);
    }

    .btn-primary:hover {
      background: radial-gradient(circle at top left, #38bdf8, #0ea5e9);
    }

    .btn-icon {
      width: 2.1rem;
      height: 2.1rem;
      border-radius: 0.7rem;
      padding: 0;
    }

    .btn-icon.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: #020617;
    }

    .btn-ghost {
      background: transparent;
    }

    .btn-danger {
      border-color: #7f1d1d;
      background: linear-gradient(135deg, #991b1b, #450a0a);
    }

    .toggle-btn {
      font-size: 0.8rem;
      padding-inline: 0.6rem;
    }

    .canvas-wrap {
      position: relative;
      padding: 0.9rem 1.1rem 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .canvas-shell {
      flex: 1;
      min-height: 0;
      background: radial-gradient(circle at top left, #020617 0, #030712 40%, #020617 100%);
      border-radius: 0.75rem;
      border: 1px solid #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem;
      overflow: auto;
    }

    .canvas-container {
      background: #111827;
      border-radius: 0.75rem;
      padding: 0.45rem;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 18px 40px rgba(0, 0, 0, 0.9);
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      image-rendering: pixelated;
      background: white;
      border-radius: 0.4rem;
    }

    .status-bar {
      font-size: 0.75rem;
      color: #9ca3af;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
      padding: 0 0.1rem;
    }

    .pill {
      border-radius: 999px;
      border: 1px solid #111827;
      padding: 0.1rem 0.45rem;
      background: #020617;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>
        <span class="logo-dot"></span>
        Pixely
      </h1>
      <div class="header-actions">
        <button id="exportPngBtn" class="btn btn-primary" type="button">PNG</button>
        <button id="exportGifBtn" class="btn btn-ghost" type="button">GIF</button>
      </div>
    </header>

    <main>
      <aside class="sidebar">
        <!-- Frames -->
        <div class="section">
          <div class="section-title">Frames</div>
          <div class="row">
            <button id="prevFrameBtn" class="btn btn-icon" title="Vorheriger Frame">‚óÄ</button>
            <div id="frameLabel" class="pill">Frame 1 / 1</div>
            <button id="nextFrameBtn" class="btn btn-icon" title="N√§chster Frame">‚ñ∂</button>
            <button id="addFrameBtn" class="btn btn-icon" title="Frame hinzuf√ºgen">Ôºã</button>
            <button id="deleteFrameBtn" class="btn btn-icon" title="Frame l√∂schen">üóë</button>
          </div>
        </div>

        <!-- Raster -->
        <div class="section">
          <div class="section-title">Raster</div>
          <div class="row">
            <label for="presetSize">Preset</label>
            <select id="presetSize">
              <option value="8x8">8√ó8</option>
              <option value="5x5">5√ó5</option>
              <option value="16x16">16√ó16</option>
              <option value="32x32">32√ó32</option>
              <option value="48x48">48√ó48</option>
              <option value="64x64">64√ó64</option>
            </select>
          </div>
          <div class="row">
            <label for="customWidth">B</label>
            <input id="customWidth" type="number" min="5" max="64" value="8" />
            <label for="customHeight">H</label>
            <input id="customHeight" type="number" min="5" max="64" value="8" />
            <button id="applySizeBtn" class="btn btn-icon" title="Raster neu">‚Üª</button>
          </div>
        </div>

        <!-- Tools -->
        <div class="section">
          <div class="section-title">Werkzeuge</div>
          <div class="row">
            <input id="colorPicker" type="color" value="#ff0055" />
            <button id="brushBtn" class="btn btn-icon active" title="Stift">‚úèÔ∏è</button>
            <button id="eraserBtn" class="btn btn-icon" title="Radierer">üßΩ</button>
            <button id="rectBtn" class="btn btn-icon" title="Rechteck">‚ñ¢</button>
            <button id="circleBtn" class="btn btn-icon" title="Kreis/Oval">‚óØ</button>
          </div>
          <div class="row">
            <button id="fillToggleBtn" class="btn toggle-btn" title="Fl√§che f√ºllen">Fill</button>
            <button id="mirrorToggleBtn" class="btn toggle-btn" title="Vertikaler Spiegelstift">‚áã</button>
          </div>
          <div class="row">
            <label for="brushSize">Stift</label>
            <input id="brushSize" type="range" min="1" max="4" value="1" />
            <span id="brushSizeLabel" style="font-size:0.75rem;color:#9ca3af;">1</span>
          </div>
        </div>

        <!-- Speicher -->
        <div class="section">
          <div class="section-title">Bild</div>
          <div class="row">
            <button id="saveBtn" class="btn" type="button">üíæ</button>
            <button id="loadBtn" class="btn" type="button">üìÇ</button>
            <button id="clearBtn" class="btn btn-danger" type="button">Clear</button>
            <input id="loadInput" type="file" accept="application/json" style="display:none" />
          </div>
        </div>
      </aside>

      <section class="canvas-wrap">
        <div class="canvas-shell">
          <div class="canvas-container">
            <canvas id="pixelCanvas" width="1024" height="1024"></canvas>
          </div>
        </div>
        <div class="status-bar">
          <div id="statusText">Bereit</div>
          <div id="gridInfo" class="pill">8√ó8</div>
        </div>
      </section>
    </main>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("pixelCanvas");
      const ctx = canvas.getContext("2d");

      const presetSize = document.getElementById("presetSize");
      const customWidthInput = document.getElementById("customWidth");
      const customHeightInput = document.getElementById("customHeight");
      const applySizeBtn = document.getElementById("applySizeBtn");

      const prevFrameBtn = document.getElementById("prevFrameBtn");
      const nextFrameBtn = document.getElementById("nextFrameBtn");
      const addFrameBtn = document.getElementById("addFrameBtn");
      const deleteFrameBtn = document.getElementById("deleteFrameBtn");
      const frameLabel = document.getElementById("frameLabel");

      const colorPicker = document.getElementById("colorPicker");
      const brushBtn = document.getElementById("brushBtn");
      const eraserBtn = document.getElementById("eraserBtn");
      const rectBtn = document.getElementById("rectBtn");
      const circleBtn = document.getElementById("circleBtn");
      const fillToggleBtn = document.getElementById("fillToggleBtn");
      const mirrorToggleBtn = document.getElementById("mirrorToggleBtn");
      const brushSizeInput = document.getElementById("brushSize");
      const brushSizeLabel = document.getElementById("brushSizeLabel");

      const saveBtn = document.getElementById("saveBtn");
      const loadBtn = document.getElementById("loadBtn");
      const loadInput = document.getElementById("loadInput");
      const clearBtn = document.getElementById("clearBtn");

      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportGifBtn = document.getElementById("exportGifBtn");

      const statusText = document.getElementById("statusText");
      const gridInfo = document.getElementById("gridInfo");

      const CANVAS_SIZE = 1024;
      canvas.width = CANVAS_SIZE;
      canvas.height = CANVAS_SIZE;

      const MIN_SIZE = 5;
      const MAX_SIZE = 64;

      let gridWidth = 8;
      let gridHeight = 8;
      let cellWidth = CANVAS_SIZE / gridWidth;
      let cellHeight = CANVAS_SIZE / gridHeight;

      let frames = [];
      let currentFrameIndex = 0;

      let currentTool = "brush"; // "brush" | "eraser" | "rect" | "circle"
      let currentColor = colorPicker.value;
      let brushSize = 1;
      let fillMode = false;
      let mirrorMode = false;

      let isDrawing = false;
      let isShapeDrawing = false;
      let shapeStart = null;
      let shapeCurrent = null;

      const toolButtons = {
        brush: brushBtn,
        eraser: eraserBtn,
        rect: rectBtn,
        circle: circleBtn,
      };

      function setStatus(msg) {
        statusText.textContent = msg;
      }

      function createEmptyGrid(width, height) {
        return Array.from({ length: height }, () => Array(width).fill(null));
      }

      function initFrames() {
        frames = [createEmptyGrid(gridWidth, gridHeight)];
        currentFrameIndex = 0;
      }

      function getCurrentGrid() {
        return frames[currentFrameIndex];
      }

      function updateGridInfo() {
        gridInfo.textContent = `${gridWidth}√ó${gridHeight}`;
      }

      function updateFrameLabel() {
        frameLabel.textContent = `Frame ${currentFrameIndex + 1} / ${frames.length}`;
      }

      function drawGridToContext(ctxTarget, dataGrid, width, height, withLines) {
        const cw = CANVAS_SIZE / width;
        const ch = CANVAS_SIZE / height;

        ctxTarget.fillStyle = "#ffffff";
        ctxTarget.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const color = dataGrid[y][x];
            if (color) {
              ctxTarget.fillStyle = color;
              ctxTarget.fillRect(
                x * cw,
                y * ch,
                Math.ceil(cw),
                Math.ceil(ch)
              );
            }
          }
        }

        if (withLines) {
          ctxTarget.save();
          ctxTarget.strokeStyle = "#d1d5db";
          ctxTarget.lineWidth = 2;
          ctxTarget.setLineDash([]);
          ctxTarget.globalAlpha = 0.7;

          for (let x = 0; x <= width; x++) {
            const px = x * cw + 0.5;
            ctxTarget.beginPath();
            ctxTarget.moveTo(px, 0);
            ctxTarget.lineTo(px, CANVAS_SIZE);
            ctxTarget.stroke();
          }
          for (let y = 0; y <= height; y++) {
            const py = y * ch + 0.5;
            ctxTarget.beginPath();
            ctxTarget.moveTo(0, py);
            ctxTarget.lineTo(CANVAS_SIZE, py);
            ctxTarget.stroke();
          }
          ctxTarget.restore();
        }
      }

      function redrawCanvas() {
        const grid = getCurrentGrid();
        drawGridToContext(ctx, grid, gridWidth, gridHeight, true);
      }

      function resizeAllFrames(newWidth, newHeight) {
        newWidth = Math.max(MIN_SIZE, Math.min(MAX_SIZE, newWidth));
        newHeight = Math.max(MIN_SIZE, Math.min(MAX_SIZE, newHeight));

        gridWidth = newWidth;
        gridHeight = newHeight;
        cellWidth = CANVAS_SIZE / gridWidth;
        cellHeight = CANVAS_SIZE / gridHeight;

        frames = frames.map(() => createEmptyGrid(gridWidth, gridHeight));
        currentFrameIndex = 0;
        shapeStart = null;
        shapeCurrent = null;
        isShapeDrawing = false;

        redrawCanvas();
        updateGridInfo();
        updateFrameLabel();
        setStatus(`Raster: ${gridWidth}√ó${gridHeight}`);
      }

      function presetChanged() {
        const [w, h] = presetSize.value.split("x").map(Number);
        customWidthInput.value = w;
        customHeightInput.value = h;
        resizeAllFrames(w, h);
      }

      function applyCustomSize() {
        const w = parseInt(customWidthInput.value, 10);
        const h = parseInt(customHeightInput.value, 10);
        if (Number.isNaN(w) || Number.isNaN(h)) {
          setStatus("Ung√ºltige Rastergr√∂√üe");
          return;
        }
        if (w < MIN_SIZE || w > MAX_SIZE || h < MIN_SIZE || h > MAX_SIZE) {
          setStatus(`Raster 5‚Äì64 zul√§ssig`);
          return;
        }
        resizeAllFrames(w, h);
      }

      function setTool(tool) {
        currentTool = tool;
        isShapeDrawing = false;
        shapeStart = null;
        shapeCurrent = null;
        Object.values(toolButtons).forEach(btn => btn.classList.remove("active"));
        if (toolButtons[tool]) toolButtons[tool].classList.add("active");
      }

      function toggleFill() {
        fillMode = !fillMode;
        fillToggleBtn.classList.toggle("active", fillMode);
      }

      function toggleMirror() {
        mirrorMode = !mirrorMode;
        mirrorToggleBtn.classList.toggle("active", mirrorMode);
      }

      function clearCurrentFrame() {
        frames[currentFrameIndex] = createEmptyGrid(gridWidth, gridHeight);
        isShapeDrawing = false;
        shapeStart = null;
        shapeCurrent = null;
        redrawCanvas();
      }

      function saveImage() {
        const data = {
          width: gridWidth,
          height: gridHeight,
          frames,
        };
        const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `pixely-${gridWidth}x${gridHeight}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function loadImageFromFile(file) {
        const reader = new FileReader();
        reader.onload = e => {
          try {
            const data = JSON.parse(e.target.result);
            if (
              !data ||
              typeof data.width !== "number" ||
              typeof data.height !== "number" ||
              !Array.isArray(data.frames)
            ) {
              throw new Error("Format");
            }
            if (
              data.width < MIN_SIZE || data.width > MAX_SIZE ||
              data.height < MIN_SIZE || data.height > MAX_SIZE
            ) {
              throw new Error("Rasterbereich 5‚Äì64");
            }
            gridWidth = data.width;
            gridHeight = data.height;
            cellWidth = CANVAS_SIZE / gridWidth;
            cellHeight = CANVAS_SIZE / gridHeight;
            frames = data.frames;
            currentFrameIndex = 0;
            customWidthInput.value = gridWidth;
            customHeightInput.value = gridHeight;
            presetSize.value = `${gridWidth}x${gridHeight}` in Object.create(null) ? `${gridWidth}x${gridHeight}` : "8x8";

            redrawCanvas();
            updateGridInfo();
            updateFrameLabel();
          } catch (err) {
            console.error(err);
            setStatus("Fehler beim Laden");
          }
        };
        reader.readAsText(file);
      }

      function getCellFromEvent(ev) {
        const rect = canvas.getBoundingClientRect();
        const point =
          (ev.touches && ev.touches[0]) ||
          (ev.changedTouches && ev.changedTouches[0]) ||
          ev;
        const clientX = point.clientX;
        const clientY = point.clientY;

        const x = Math.floor(((clientX - rect.left) / rect.width) * gridWidth);
        const y = Math.floor(((clientY - rect.top) / rect.height) * gridHeight);
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return null;
        return { x, y };
      }

      function paintCellAt(grid, x, y, color) {
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;
        grid[y][x] = color;
      }

      function paintBrush(cell) {
        const grid = getCurrentGrid();
        const color = currentTool === "eraser" ? null : currentColor;
        const r = brushSize - 1;
        for (let dy = -r; dy <= r; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            const nx = cell.x + dx;
            const ny = cell.y + dy;
            paintCellAt(grid, nx, ny, color);
            if (mirrorMode) {
              const mx = gridWidth - 1 - nx;
              paintCellAt(grid, mx, ny, color);
            }
          }
        }
        redrawCanvas();
      }

      function drawRectShape(start, end, color, targetGrid) {
        const x1 = Math.min(start.x, end.x);
        const x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const y2 = Math.max(start.y, end.y);

        if (fillMode) {
          for (let y = y1; y <= y2; y++) {
            for (let x = x1; x <= x2; x++) {
              paintCellAt(targetGrid, x, y, color);
            }
          }
        } else {
          for (let x = x1; x <= x2; x++) {
            paintCellAt(targetGrid, x, y1, color);
            paintCellAt(targetGrid, x, y2, color);
          }
          for (let y = y1; y <= y2; y++) {
            paintCellAt(targetGrid, x1, y, color);
            paintCellAt(targetGrid, x2, y, color);
          }
        }
      }

      function drawCircleShape(start, end, color, targetGrid) {
        const x1 = Math.min(start.x, end.x);
        const x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const y2 = Math.max(start.y, end.y);

        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const rx = (x2 - x1) / 2 || 0.5;
        const ry = (y2 - y1) / 2 || 0.5;

        for (let y = y1; y <= y2; y++) {
          for (let x = x1; x <= x2; x++) {
            const dx = (x - cx) / rx;
            const dy = (y - cy) / ry;
            const dist = dx * dx + dy * dy;
            if (fillMode) {
              if (dist <= 1.0) {
                paintCellAt(targetGrid, x, y, color);
              }
            } else {
              if (dist <= 1.05 && dist >= 0.7) {
                paintCellAt(targetGrid, x, y, color);
              }
            }
          }
        }
      }

      function applyShape(start, end) {
        if (!start || !end) return;
        const grid = getCurrentGrid();
        const color = currentColor;
        const tempGrid = grid;

        if (currentTool === "rect") {
          drawRectShape(start, end, color, tempGrid);
        } else if (currentTool === "circle") {
          drawCircleShape(start, end, color, tempGrid);
        }

        if (mirrorMode) {
          const mirroredGrid = getCurrentGrid();
          const w = gridWidth;
          // Spiegeln: wir zeichnen die Form gespiegelt per zweite Runde
          if (currentTool === "rect") {
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawRectShape(ms, me, color, mirroredGrid);
          } else if (currentTool === "circle") {
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawCircleShape(ms, me, color, mirroredGrid);
          }
        }

        redrawCanvas();
      }

      function previewShape(start, end) {
        const original = getCurrentGrid();
        const copy = original.map(row => row.slice());
        const color = currentColor;

        if (currentTool === "rect") {
          drawRectShape(start, end, color, copy);
        } else if (currentTool === "circle") {
          drawCircleShape(start, end, color, copy);
        }

        if (mirrorMode) {
          const w = gridWidth;
          if (currentTool === "rect") {
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawRectShape(ms, me, color, copy);
          } else if (currentTool === "circle") {
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawCircleShape(ms, me, color, copy);
          }
        }

        drawGridToContext(ctx, copy, gridWidth, gridHeight, true);
      }

      function handlePointerDown(ev) {
        const cell = getCellFromEvent(ev);
        if (!cell) return;

        if (currentTool === "brush" || currentTool === "eraser") {
          isDrawing = true;
          paintBrush(cell);
        } else {
          isShapeDrawing = true;
          shapeStart = cell;
          shapeCurrent = cell;
          previewShape(shapeStart, shapeCurrent);
        }
      }

      function handlePointerMove(ev) {
        const cell = getCellFromEvent(ev);
        if (!cell) return;

        if (isDrawing && (currentTool === "brush" || currentTool === "eraser")) {
          paintBrush(cell);
        } else if (isShapeDrawing && shapeStart && (currentTool === "rect" || currentTool === "circle")) {
          shapeCurrent = cell;
          previewShape(shapeStart, shapeCurrent);
        }
      }

      function handlePointerUp() {
        if (isDrawing) {
          isDrawing = false;
          return;
        }
        if (isShapeDrawing) {
          isShapeDrawing = false;
          if (shapeStart && shapeCurrent) {
            applyShape(shapeStart, shapeCurrent);
          } else {
            redrawCanvas();
          }
          shapeStart = null;
          shapeCurrent = null;
        }
      }

      function exportPNG() {
        const a = document.createElement("a");
        a.download = `pixely-${gridWidth}x${gridHeight}-frame${currentFrameIndex + 1}.png`;
        a.href = canvas.toDataURL("image/png");
        a.click();
      }

      function exportGIF() {
        if (typeof GIF === "undefined") {
          setStatus("gif.js nicht geladen");
          return;
        }
        if (!frames.length) {
          setStatus("Keine Frames");
          return;
        }

        const gif = new GIF({
          workers: 2,
          quality: 10,
          workerScript: "https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js"
        });

        frames.forEach(gridFrame => {
          const off = document.createElement("canvas");
          off.width = CANVAS_SIZE;
          off.height = CANVAS_SIZE;
          const offCtx = off.getContext("2d");
          drawGridToContext(offCtx, gridFrame, gridWidth, gridHeight, false);
          gif.addFrame(offCtx, { delay: 300 });
        });

        gif.on("finished", function (blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `pixely-${gridWidth}x${gridHeight}.gif`;
          a.click();
          URL.revokeObjectURL(url);
        });

        gif.render();
        setStatus("GIF wird erstellt ‚Ä¶");
      }

      function addFrame() {
        const base = getCurrentGrid();
        const clone = base.map(row => row.slice());
        frames.splice(currentFrameIndex + 1, 0, clone);
        currentFrameIndex++;
        updateFrameLabel();
        redrawCanvas();
      }

      function deleteFrame() {
        if (frames.length <= 1) {
          clearCurrentFrame();
          return;
        }
        frames.splice(currentFrameIndex, 1);
        if (currentFrameIndex >= frames.length) {
          currentFrameIndex = frames.length - 1;
        }
        updateFrameLabel();
        redrawCanvas();
      }

      function prevFrame() {
        currentFrameIndex = (currentFrameIndex - 1 + frames.length) % frames.length;
        updateFrameLabel();
        redrawCanvas();
      }

      function nextFrame() {
        currentFrameIndex = (currentFrameIndex + 1) % frames.length;
        updateFrameLabel();
        redrawCanvas();
      }

      // Event-Bindings
      presetSize.addEventListener("change", presetChanged);
      applySizeBtn.addEventListener("click", applyCustomSize);

      prevFrameBtn.addEventListener("click", prevFrame);
      nextFrameBtn.addEventListener("click", nextFrame);
      addFrameBtn.addEventListener("click", addFrame);
      deleteFrameBtn.addEventListener("click", deleteFrame);

      brushBtn.addEventListener("click", () => setTool("brush"));
      eraserBtn.addEventListener("click", () => setTool("eraser"));
      rectBtn.addEventListener("click", () => setTool("rect"));
      circleBtn.addEventListener("click", () => setTool("circle"));

      fillToggleBtn.addEventListener("click", toggleFill);
      mirrorToggleBtn.addEventListener("click", toggleMirror);

      colorPicker.addEventListener("input", e => {
        currentColor = e.target.value;
      });

      brushSizeInput.addEventListener("input", e => {
        brushSize = parseInt(e.target.value, 10) || 1;
        brushSizeLabel.textContent = brushSize;
      });

      saveBtn.addEventListener("click", saveImage);
      loadBtn.addEventListener("click", () => loadInput.click());
      loadInput.addEventListener("change", e => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        loadImageFromFile(file);
        loadInput.value = "";
      });

      clearBtn.addEventListener("click", clearCurrentFrame);

      exportPngBtn.addEventListener("click", exportPNG);
      exportGifBtn.addEventListener("click", exportGIF);

      canvas.addEventListener("mousedown", handlePointerDown);
      canvas.addEventListener("mousemove", handlePointerMove);
      window.addEventListener("mouseup", handlePointerUp);

      canvas.addEventListener("touchstart", e => {
        e.preventDefault();
        handlePointerDown(e);
      }, { passive: false });

      canvas.addEventListener("touchmove", e => {
        e.preventDefault();
        handlePointerMove(e);
      }, { passive: false });

      canvas.addEventListener("touchend", e => {
        e.preventDefault();
        handlePointerUp();
      }, { passive: false });

      // Init
      initFrames();
      redrawCanvas();
      updateGridInfo();
      updateFrameLabel();
      setTool("brush");
      brushSize = parseInt(brushSizeInput.value, 10) || 1;
    })();
  </script>
</body>
</html>
