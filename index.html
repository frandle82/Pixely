<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Pixely – Pixel-Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- GIF.js für animierte GIF-Erstellung -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --border: #1f2937;
    }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 1rem;
    }

    .app {
      max-width: 1200px;
      width: 100%;
      background: #020617;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      box-shadow: 0 25px 60px rgba(15, 23, 42, 0.8);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin: 0;
    }

    .logo-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: linear-gradient(135deg, #22c55e, #38bdf8);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.8);
    }

    .header-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 180px minmax(0, 1fr) 260px;
      min-height: 440px;
      max-height: 80vh;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 150px minmax(0, 1fr);
        grid-template-rows: minmax(0, 1fr) auto;
        grid-template-areas:
          "frames canvas"
          "tools tools";
      }
      .frames-panel { grid-area: frames; }
      .canvas-area { grid-area: canvas; }
      .tools-panel { grid-area: tools; border-left: none; border-top: 1px solid var(--border); }
    }

    .btn {
      border-radius: 999px;
      border: 1px solid #111827;
      background: #020617;
      font-size: 0.8rem;
      padding: 0.3rem 0.75rem;
      color: #e5e7eb;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
      cursor: pointer;
      outline: none;
      white-space: nowrap;
      transition: background 0.12s ease, border-color 0.12s ease, transform 0.06s ease;
    }
    .btn:hover { background: #030712; transform: translateY(-0.5px); }
    .btn-primary {
      border-color: var(--accent);
      background: radial-gradient(circle at top left, #0ea5e9, #0369a1);
    }
    .btn-primary:hover {
      background: radial-gradient(circle at top left, #38bdf8, #0ea5e9);
    }

    .btn-icon {
      width: 2.1rem;
      height: 2.1rem;
      padding: 0;
      border-radius: 0.7rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #020617;
    }
    .btn-icon.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    .btn-ghost { background: transparent; }

    .icon {
      width: 18px;
      height: 18px;
      stroke: #e5e7eb;
      fill: none;
      stroke-width: 1.7;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .pill {
      border-radius: 999px;
      border: 1px solid #111827;
      padding: 0.1rem 0.45rem;
      background: #020617;
      font-size: 0.75rem;
    }

    /* Frames links */
    .frames-panel {
      border-right: 1px solid var(--border);
      padding: 0.6rem 0.5rem 0.6rem 0.6rem;
      background: #020617;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .frames-header-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      margin-bottom: 0.2rem;
    }

    #framesList {
      flex: 1;
      overflow-y: auto;
      padding-right: 0.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .frame-item {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.35rem;
      border-radius: 0.6rem;
      border: 1px solid #111827;
      background: #020617;
      cursor: pointer;
      transition: background 0.1s ease, border-color 0.1s ease;
    }
    .frame-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    .frame-item.drag-over {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
    .frame-item.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: #030712;
    }
    .frame-thumb-wrap {
      position: relative;
      width: 82px;
      height: 82px;
      flex-shrink: 0;
    }
    .frame-thumb {
      width: 100%;
      height: 100%;
      border-radius: 0.45rem;
      background: #111827;
      border: 1px solid #0b1221;
      display: block;
    }

    .frame-index-badge {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 18px;
      height: 18px;
      border-radius: 4px;
      background: #111827;
      color: #e5e7eb;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .frame-item.active .frame-index-badge {
      background: var(--accent);
      color: #020617;
    }

    .frame-actions {
      position: absolute;
      inset: 4px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      pointer-events: none;
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 0.14s ease, transform 0.14s ease;
    }
    .frame-item:hover .frame-actions,
    .frame-item.show-actions .frame-actions {
      opacity: 1;
      transform: translateY(0);
    }
    .frame-actions button {
      pointer-events: auto;
      border-radius: 0.65rem;
      border: 1px solid #0b1221;
      background: rgba(15, 23, 42, 0.94);
      width: 28px;
      height: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
    }
    .frame-actions svg {
      width: 15px;
      height: 15px;
      stroke-width: 1.6;
    }
    .frame-actions .top-left { justify-self: start; align-self: start; }
    .frame-actions .top-right { justify-self: end; align-self: start; }
    .frame-actions .bottom-left { justify-self: start; align-self: end; }
    .frame-actions .bottom-right { justify-self: end; align-self: end; }

    .new-frame-btn {
      margin-top: 0.4rem;
      padding: 0.35rem 0.5rem;
      border-radius: 0.6rem;
      border: 1px dashed #4b5563;
      background: rgba(15, 23, 42, 0.5);
      color: #9ca3af;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
    }
    .new-frame-btn:hover {
      background: rgba(15, 23, 42, 0.8);
      border-color: #6b7280;
    }
    .new-frame-btn-icon {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid #6b7280;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
    }

    /* Canvas Mitte */
    .canvas-area {
      padding: 0.8rem 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      background: radial-gradient(circle at top, #020617 0, #020617 45%, #020617 100%);
    }

    .canvas-shell {
      flex: 1;
      background: radial-gradient(circle at top left, #020617 0, #030712 40%, #020617 100%);
      border-radius: 0.75rem;
      border: 1px solid #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem;
      overflow: auto;
    }

    .canvas-container {
      background: #111827;
      border-radius: 0.75rem;
      padding: 0.45rem;
      box-shadow:
        0 0 0 1px rgba(15, 23, 42, 0.9),
        0 16px 36px rgba(0, 0, 0, 0.9);
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      image-rendering: pixelated;
      background: #ffffff; /* nur Anzeige; Export bleibt transparent */
      border-radius: 0.4rem;
    }

    .status-bar {
      font-size: 0.75rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    /* Tools rechts */
    .tools-panel {
      border-left: 1px solid var(--border);
      padding: 0.6rem 0.7rem;
      background: #020617;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .section-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #6b7280;
      margin-bottom: 0.2rem;
    }

    .section {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .preview-card {
      border: 1px solid #111827;
      border-radius: 0.6rem;
      padding: 0.6rem;
      background: #030712;
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }

    .preview-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    #gifPreviewCanvas {
      width: 100%;
      max-width: 220px;
      aspect-ratio: 1 / 1;
      border-radius: 0.5rem;
      background: #0b1221;
      border: 1px dashed #1f2937;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.35rem;
    }

    label {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    select,
    input[type="number"] {
      background: #020617;
      border-radius: 0.4rem;
      border: 1px solid #111827;
      padding: 0.3rem 0.45rem;
      font-size: 0.8rem;
      color: #e5e7eb;
      outline: none;
      min-width: 0;
    }

    select:focus,
    input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    input[type="color"] {
      appearance: none;
      -webkit-appearance: none;
      border: none;
      padding: 0;
      width: 2rem;
      height: 2rem;
      border-radius: 0.6rem;
      cursor: pointer;
      overflow: hidden;
      box-shadow: 0 0 0 1px #111827, 0 0 0 3px #020617;
    }
    input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
    input[type="color"]::-webkit-color-swatch { border: none; }

    .brush-size-btn {
      width: 1.9rem;
      height: 1.9rem;
      border-radius: 0.6rem;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .brush-size-icon {
      width: 12px;
      height: 12px;
      background: #e5e7eb;
      border-radius: 2px;
    }
    .brush-size-btn[data-size="2"] .brush-size-icon {
      width: 16px;
      height: 16px;
    }
    .brush-size-btn[data-size="3"] .brush-size-icon {
      width: 18px;
      height: 18px;
    }
    .brush-size-btn[data-size="4"] .brush-size-icon {
      width: 20px;
      height: 20px;
    }
    .brush-size-btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .toggle-btn {
      font-size: 0.8rem;
      padding-inline: 0.6rem;
      border-radius: 0.7rem;
      background: #020617;
    }
    .toggle-btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1><span class="logo-dot"></span>Pixely</h1>
      <div class="header-actions">
        <button id="exportPngBtn" class="btn btn-primary" title="Aktuellen Frame als PNG exportieren">
          PNG
        </button>
        <button id="exportGifBtn" class="btn btn-ghost" title="Alle Frames als GIF exportieren">
          GIF
        </button>
      </div>
    </header>

    <main>
      <!-- FRAMES LINKS -->
      <aside class="frames-panel">
        <div class="frames-header-title">Frames</div>
        <div id="framesList"></div>
        <button id="newFrameBtn" class="new-frame-btn" type="button">
          <span class="new-frame-btn-icon">+</span>
          <span>Erstelle neues Bild</span>
        </button>
      </aside>

      <!-- CANVAS MITTE -->
      <section class="canvas-area">
        <div class="canvas-shell">
          <div class="canvas-container">
            <canvas id="pixelCanvas" width="1024" height="1024"></canvas>
          </div>
        </div>
        <div class="status-bar">
          <div id="statusText">Bereit</div>
          <div id="gridInfo" class="pill">8×8 | Frame 1/1</div>
        </div>
      </section>

      <!-- TOOLS RECHTS -->
      <aside class="tools-panel">
        <!-- Raster -->
        <div class="section">
          <div class="section-title">Raster</div>
          <div class="row">
            <label for="presetSize">Voreinstellung</label>
            <select id="presetSize">
              <option value="8x8">8×8</option>
              <option value="5x5">5×5</option>
              <option value="16x16">16×16</option>
              <option value="32x32">32×32</option>
              <option value="48x48">48×48</option>
              <option value="64x64">64×64</option>
            </select>
          </div>
          <div class="row">
            <label for="customWidth">B</label>
            <input id="customWidth" type="number" min="5" max="64" value="8" />
            <label for="customHeight">H</label>
            <input id="customHeight" type="number" min="5" max="64" value="8" />
            <button id="applySizeBtn" class="btn-icon btn-ghost" title="Rastergröße übernehmen">
              <svg viewBox="0 0 24 24" class="icon">
                <rect x="4" y="4" width="16" height="16" rx="1.5"></rect>
                <path d="M4 10h16"></path>
                <path d="M10 4v16"></path>
              </svg>
            </button>
          </div>
        </div>

        <!-- Zeichenwerkzeuge -->
        <div class="section">
          <div class="section-title">Zeichnen</div>
          <div class="row">
            <input id="colorPicker" type="color" value="#ff0055" title="Farbe wählen" />
            <!-- Stift (Pinsel) -->
            <button id="brushBtn" class="btn-icon active" title="Stift">
              <svg viewBox="0 0 24 24" class="icon">
                <path d="M4 20l4.5-1.2L19 8.3a1.8 1.8 0 0 0 0-2.5L18.2 5a1.8 1.8 0 0 0-2.5 0L6 14.7 4 20z"></path>
                <path d="M11 7l3 3"></path>
              </svg>
            </button>
            <!-- Radiergummi -->
            <button id="eraserBtn" class="btn-icon" title="Radierer">
              <svg viewBox="0 0 24 24" class="icon">
                <path d="M4 15l6-6 4 4-6 6H4z"></path>
                <path d="M10 9l3-3 5 5-3 3"></path>
                <line x1="4" y1="21" x2="14" y2="21"></line>
              </svg>
            </button>
          </div>
          <div class="row">
            <!-- Rechteck (Umriss) -->
            <button id="rectBtn" class="btn-icon" title="Rechteck (Umriss)">
              <svg viewBox="0 0 24 24" class="icon">
                <rect x="5" y="6" width="14" height="12" rx="1.5"></rect>
              </svg>
            </button>
            <!-- Kreis/Oval (Umriss) -->
            <button id="circleBtn" class="btn-icon" title="Kreis/Oval (Umriss)">
              <svg viewBox="0 0 24 24" class="icon">
                <ellipse cx="12" cy="12" rx="7" ry="5"></ellipse>
              </svg>
            </button>
            <!-- Füllen (Farbeimer) -->
            <button id="fillBtn" class="btn-icon" title="Fläche füllen">
              <svg viewBox="0 0 24 24" class="icon">
                <path d="M7 3l10 10-3 3L4 6z"></path>
                <path d="M4 6l9 9"></path>
                <path d="M18 16a3 3 0 0 0 6 0c0-1.7-1.3-3-3-3s-3 1.3-3 3z"></path>
              </svg>
            </button>
            <!-- Vertikale Spiegelung -->
            <button id="mirrorToggleBtn" class="btn toggle-btn" title="Vertikale Spiegelung an/aus">
              <svg viewBox="0 0 24 24" class="icon">
                <line x1="12" y1="4" x2="12" y2="20"></line>
                <polyline points="7 7 4 10 7 13"></polyline>
                <polyline points="17 7 20 10 17 13"></polyline>
              </svg>
            </button>
          </div>
          <div class="row">
            <label>Stiftgröße</label>
            <button data-size="1" class="btn brush-size-btn active" title="1×1">
              <div class="brush-size-icon"></div>
            </button>
            <button data-size="2" class="btn brush-size-btn" title="2×2">
              <div class="brush-size-icon"></div>
            </button>
            <button data-size="3" class="btn brush-size-btn" title="3×3">
              <div class="brush-size-icon"></div>
            </button>
            <button data-size="4" class="btn brush-size-btn" title="4×4">
              <div class="brush-size-icon"></div>
            </button>
          </div>
        </div>

        <!-- Bild -->
        <div class="section">
          <div class="section-title">Bild</div>
          <div class="row">
            <button id="saveBtn" class="btn" title="Projekt speichern (JSON)">
              Speichern
            </button>
            <button id="loadBtn" class="btn" title="Projekt laden (JSON)">
              Laden
            </button>
            <!-- Raster leeren -->
            <button id="clearBtn" class="btn btn-ghost" title="Aktuellen Frame vollständig leeren">
              <svg viewBox="0 0 24 24" class="icon">
                <rect x="4" y="4" width="16" height="16" rx="1.5"></rect>
                <path d="M6 6h4"></path>
                <path d="M6 10h2"></path>
                <path d="M6 14h3"></path>
                <path d="M6 18h2"></path>
                <path d="M18 6l-5 5"></path>
                <path d="M15 6h3v3"></path>
              </svg>
            </button>
            <input id="loadInput" type="file" accept="application/json" style="display:none" />
          </div>
        </div>

        <!-- GIF Vorschau -->
        <div class="section">
          <div class="section-title">GIF &amp; Vorschau</div>
          <div class="preview-card">
            <div class="preview-controls">
              <label for="gifFpsInput">FPS</label>
              <input id="gifFpsInput" type="range" min="1" max="24" value="5" />
              <span id="gifFpsValue" class="pill">5 FPS</span>
            </div>
            <canvas id="gifPreviewCanvas" width="200" height="200"></canvas>
            <div class="preview-controls">
              <button id="togglePreviewBtn" class="btn">Vorschau abspielen</button>
              <button id="restartPreviewBtn" class="btn btn-ghost">Neu starten</button>
            </div>
          </div>
        </div>
      </aside>
    </main>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("pixelCanvas");
      const ctx = canvas.getContext("2d");

      const presetSize = document.getElementById("presetSize");
      const customWidthInput = document.getElementById("customWidth");
      const customHeightInput = document.getElementById("customHeight");
      const applySizeBtn = document.getElementById("applySizeBtn");

      const framesList = document.getElementById("framesList");
      const newFrameBtn = document.getElementById("newFrameBtn");
      const gridInfo = document.getElementById("gridInfo");
      const statusText = document.getElementById("statusText");

      const colorPicker = document.getElementById("colorPicker");
      const brushBtn = document.getElementById("brushBtn");
      const eraserBtn = document.getElementById("eraserBtn");
      const rectBtn = document.getElementById("rectBtn");
      const circleBtn = document.getElementById("circleBtn");
      const fillBtn = document.getElementById("fillBtn");
      const mirrorToggleBtn = document.getElementById("mirrorToggleBtn");

      const saveBtn = document.getElementById("saveBtn");
      const loadBtn = document.getElementById("loadBtn");
      const loadInput = document.getElementById("loadInput");
      const clearBtn = document.getElementById("clearBtn");
      const exportPngBtn = document.getElementById("exportPngBtn");
      const exportGifBtn = document.getElementById("exportGifBtn");
      const gifPreviewCanvas = document.getElementById("gifPreviewCanvas");
      const gifPreviewCtx = gifPreviewCanvas.getContext("2d");
      const gifFpsInput = document.getElementById("gifFpsInput");
      const gifFpsValue = document.getElementById("gifFpsValue");
      const togglePreviewBtn = document.getElementById("togglePreviewBtn");
      const restartPreviewBtn = document.getElementById("restartPreviewBtn");

      const brushSizeButtons = Array.from(document.querySelectorAll(".brush-size-btn"));

      const CANVAS_SIZE = 1024;
      canvas.width = CANVAS_SIZE;
      canvas.height = CANVAS_SIZE;

      const MIN_SIZE = 5;
      const MAX_SIZE = 64;

      let gridWidth = 8;
      let gridHeight = 8;
      let cellWidth = CANVAS_SIZE / gridWidth;
      let cellHeight = CANVAS_SIZE / gridHeight;

      let frames = [];
      let currentFrameIndex = 0;

      // Werkzeuge: "pinsel", "radierer", "rechteck", "kreis", "fuellen"
      let currentTool = "pinsel";
      let currentColor = colorPicker.value;
      let brushSize = 1; // 1..4 -> 1x1..4x4
      let mirrorMode = false;

      let isDrawing = false;
      let isShapeDrawing = false;
      let shapeStart = null;
      let shapeCurrent = null;

      let previewTimer = null;
      let previewIndex = 0;
      let previewPlaying = false;
      let dragIndex = null;
      let flashActionsIndex = null;
      let flashActionsTimeout = null;
      let gifExporting = false;

      const toolButtons = {
        pinsel: brushBtn,
        radierer: eraserBtn,
        rechteck: rectBtn,
        kreis: circleBtn,
        fuellen: fillBtn,
      };

      function setStatus(msg) {
        statusText.textContent = msg;
      }

      function flashFrameActions(index) {
        flashActionsIndex = index;
        if (flashActionsTimeout) {
          clearTimeout(flashActionsTimeout);
          flashActionsTimeout = null;
        }
      }

      function getGifDelayMs() {
        const fps = Math.max(1, Math.min(24, parseInt(gifFpsInput.value, 10) || 5));
        gifFpsInput.value = fps;
        return Math.round(1000 / fps);
      }

      function updateFpsLabel() {
        gifFpsValue.textContent = `${gifFpsInput.value} FPS`;
      }

      function renderPreviewFrame(idx) {
        if (!frames.length) return;
        previewIndex = Math.max(0, Math.min(idx, frames.length - 1));
        gifPreviewCtx.clearRect(0, 0, gifPreviewCanvas.width, gifPreviewCanvas.height);
        drawGridToContext(
          gifPreviewCtx,
          frames[previewIndex],
          gridWidth,
          gridHeight,
          false,
          gifPreviewCanvas.width
        );
      }

      function stopPreview() {
        if (previewTimer) {
          clearInterval(previewTimer);
          previewTimer = null;
        }
        previewPlaying = false;
        togglePreviewBtn.textContent = "Vorschau abspielen";
      }

      function startPreview() {
        if (!frames.length) return;
        stopPreview();
        previewPlaying = true;
        togglePreviewBtn.textContent = "Vorschau stoppen";
        const delay = getGifDelayMs();
        previewIndex = 0;
        renderPreviewFrame(previewIndex);
        previewTimer = setInterval(() => {
          previewIndex = (previewIndex + 1) % frames.length;
          renderPreviewFrame(previewIndex);
        }, delay);
      }

      function refreshPreview() {
        if (!previewPlaying) {
          renderPreviewFrame(currentFrameIndex);
        }
      }

      function createEmptyGrid(width, height) {
        return Array.from({ length: height }, () => Array(width).fill(null));
      }

      function initFrames() {
        frames = [createEmptyGrid(gridWidth, gridHeight)];
        currentFrameIndex = 0;
        renderFramesList();
        redrawCanvas();
        updateInfo();
      }

      function getCurrentGrid() {
        return frames[currentFrameIndex];
      }

      function updateInfo() {
        gridInfo.textContent = `${gridWidth}×${gridHeight} | Frame ${currentFrameIndex + 1}/${frames.length}`;
      }

      function drawGridToContext(ctxTarget, dataGrid, width, height, withLines, canvasSize = CANVAS_SIZE) {
        const cw = canvasSize / width;
        const ch = canvasSize / height;

        // Kein Hintergrund füllen -> transparent

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const color = dataGrid[y][x];
            if (color) {
              ctxTarget.fillStyle = color;
              ctxTarget.fillRect(
                x * cw,
                y * ch,
                Math.ceil(cw),
                Math.ceil(ch)
              );
            }
          }
        }

        if (withLines) {
          ctxTarget.save();
          ctxTarget.strokeStyle = "#d1d5db";
          ctxTarget.lineWidth = 2;
          ctxTarget.setLineDash([]);
          ctxTarget.globalAlpha = 0.7;

          for (let x = 0; x <= width; x++) {
            const px = x * cw + 0.5;
            ctxTarget.beginPath();
            ctxTarget.moveTo(px, 0);
            ctxTarget.lineTo(px, canvasSize);
            ctxTarget.stroke();
          }
          for (let y = 0; y <= height; y++) {
            const py = y * ch + 0.5;
            ctxTarget.beginPath();
            ctxTarget.moveTo(0, py);
            ctxTarget.lineTo(canvasSize, py);
            ctxTarget.stroke();
          }
          ctxTarget.restore();
        }
      }

      function drawThumbnail(canvas, dataGrid) {
        const tctx = canvas.getContext("2d");
        const tw = canvas.width;
        const th = canvas.height;
        const cw = tw / gridWidth;
        const ch = th / gridHeight;

        tctx.clearRect(0, 0, tw, th);
        tctx.fillStyle = "#ffffff";
        tctx.fillRect(0, 0, tw, th);

        for (let y = 0; y < gridHeight; y++) {
          for (let x = 0; x < gridWidth; x++) {
            const color = dataGrid[y][x];
            if (color) {
              tctx.fillStyle = color;
              tctx.fillRect(
                x * cw,
                y * ch,
                Math.ceil(cw),
                Math.ceil(ch)
              );
            }
          }
        }
      }

      function moveFrame(oldIndex, newIndex) {
        if (newIndex < 0 || newIndex >= frames.length) return;
        const [frame] = frames.splice(oldIndex, 1);
        frames.splice(newIndex, 0, frame);
        currentFrameIndex = newIndex;
        flashFrameActions(newIndex);
        renderFramesList();
        redrawCanvas();
        updateInfo();
      }

      function duplicateFrame(index) {
        const base = frames[index];
        const clone = base.map(row => row.slice());
        frames.splice(index + 1, 0, clone);
        currentFrameIndex = index + 1;
        flashFrameActions(currentFrameIndex);
        renderFramesList();
        redrawCanvas();
        updateInfo();
        setStatus("Frame dupliziert.");
      }

      function deleteFrame(index) {
        if (frames.length <= 1) {
          clearCurrentFrame();
          return;
        }
        frames.splice(index, 1);
        if (currentFrameIndex >= frames.length) {
          currentFrameIndex = frames.length - 1;
        }
        renderFramesList();
        redrawCanvas();
        updateInfo();
        setStatus("Frame gelöscht.");
      }

      function renderFramesList() {
        framesList.innerHTML = "";
        const total = frames.length;
        const flashIndex = flashActionsIndex;
        flashActionsIndex = null;
        frames.forEach((grid, idx) => {
          const item = document.createElement("div");
          item.className = "frame-item" + (idx === currentFrameIndex ? " active" : "");
          if (total > 1) {
            item.draggable = true;
          }
          const thumbWrap = document.createElement("div");
          thumbWrap.className = "frame-thumb-wrap";
          const thumb = document.createElement("canvas");
          thumb.className = "frame-thumb";
          thumb.width = 82;
          thumb.height = 82;
          drawThumbnail(thumb, grid);
          thumbWrap.appendChild(thumb);

          const badge = document.createElement("div");
          badge.className = "frame-index-badge";
          badge.textContent = idx + 1;
          thumbWrap.appendChild(badge);

          item.appendChild(thumbWrap);

          if (idx === currentFrameIndex) {
            const actions = document.createElement("div");
            actions.className = "frame-actions";

            if (total === 1) {
              const dupBtn = document.createElement("button");
              dupBtn.title = "Frame duplizieren";
              dupBtn.innerHTML = `
                <svg viewBox="0 0 24 24" class="icon">
                  <rect x="6" y="6" width="11" height="11" rx="1.5"></rect>
                  <rect x="9" y="9" width="11" height="11" rx="1.5"></rect>
                </svg>`;
              dupBtn.classList.add("bottom-right");
              dupBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                duplicateFrame(idx);
              });
              actions.style.justifyContent = "flex-end";
              actions.appendChild(dupBtn);
            } else {
              const copyBtn = document.createElement("button");
              copyBtn.title = "Frame kopieren";
              copyBtn.innerHTML = `
                <svg viewBox="0 0 24 24" class="icon">
                  <rect x="6" y="6" width="10" height="10" rx="1.5"></rect>
                  <rect x="10" y="10" width="8" height="8" rx="1.5"></rect>
                </svg>`;
              copyBtn.classList.add("bottom-right");
              copyBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                duplicateFrame(idx);
              });

              const delBtn = document.createElement("button");
              delBtn.title = "Frame löschen";
              delBtn.innerHTML = `
                <svg viewBox="0 0 24 24" class="icon">
                  <polyline points="9 4 10 3 14 3 15 4"></polyline>
                  <rect x="6" y="5" width="12" height="15" rx="1.5"></rect>
                  <line x1="10" y1="9" x2="10" y2="17"></line>
                  <line x1="14" y1="9" x2="14" y2="17"></line>
                </svg>`;
              delBtn.classList.add("top-left");
              delBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                deleteFrame(idx);
              });

              const moveBtn = document.createElement("button");
              moveBtn.title = "Frame verschieben";
              moveBtn.innerHTML = `
                <svg viewBox="0 0 24 24" class="icon">
                  <line x1="12" y1="4" x2="12" y2="20"></line>
                  <line x1="4" y1="12" x2="20" y2="12"></line>
                  <polyline points="9 7 12 4 15 7"></polyline>
                  <polyline points="9 17 12 20 15 17"></polyline>
                  <polyline points="7 9 4 12 7 15"></polyline>
                  <polyline points="17 9 20 12 17 15"></polyline>
                </svg>`;
              const canMoveLeft = idx > 0;
              const canMoveRight = idx < total - 1;
              moveBtn.disabled = !(canMoveLeft || canMoveRight);
              moveBtn.style.opacity = moveBtn.disabled ? "0.4" : "1";
              moveBtn.classList.add("bottom-left");
              moveBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                if (moveBtn.disabled) return;
                const rect = e.currentTarget.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const preferRight = clickX >= rect.width / 2;
                if (preferRight && canMoveRight) {
                  moveFrame(idx, idx + 1);
                } else if (!preferRight && canMoveLeft) {
                  moveFrame(idx, idx - 1);
                } else if (canMoveLeft) {
                  moveFrame(idx, idx - 1);
                } else if (canMoveRight) {
                  moveFrame(idx, idx + 1);
                }
              });

              actions.appendChild(moveBtn);
              actions.appendChild(copyBtn);
              actions.appendChild(delBtn);
            }

            thumbWrap.appendChild(actions);

            if (flashIndex === idx) {
              requestAnimationFrame(() => {
                item.classList.add("show-actions");
                flashActionsTimeout = setTimeout(() => {
                  item.classList.remove("show-actions");
                  flashActionsTimeout = null;
                }, 900);
              });
            }
          }

          item.addEventListener("click", () => {
            const changed = currentFrameIndex !== idx;
            currentFrameIndex = idx;
            if (changed) {
              flashFrameActions(idx);
            }
            renderFramesList();
            redrawCanvas();
            updateInfo();
          });

          item.addEventListener("dragstart", (e) => {
            if (total <= 1) return;
            dragIndex = idx;
            item.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
          });

          item.addEventListener("dragover", (e) => {
            if (dragIndex === null || dragIndex === idx || total <= 1) return;
            e.preventDefault();
            item.classList.add("drag-over");
            e.dataTransfer.dropEffect = "move";
          });

          item.addEventListener("dragleave", () => {
            item.classList.remove("drag-over");
          });

          item.addEventListener("drop", (e) => {
            if (dragIndex === null || dragIndex === idx || total <= 1) return;
            e.preventDefault();
            item.classList.remove("drag-over");
            const targetIndex = idx > dragIndex ? idx - 1 : idx;
            moveFrame(dragIndex, targetIndex);
            dragIndex = null;
          });

          item.addEventListener("dragend", () => {
            dragIndex = null;
            item.classList.remove("dragging");
            item.classList.remove("drag-over");
          });

          framesList.appendChild(item);
        });

        framesList.appendChild(newFrameBtn);
      }

      function redrawCanvas() {
        ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        const grid = getCurrentGrid();
        drawGridToContext(ctx, grid, gridWidth, gridHeight, true);
        refreshPreview();
      }

      function resizeAllFrames(newWidth, newHeight) {
        newWidth = Math.max(MIN_SIZE, Math.min(MAX_SIZE, newWidth));
        newHeight = Math.max(MIN_SIZE, Math.min(MAX_SIZE, newHeight));
        gridWidth = newWidth;
        gridHeight = newHeight;
        cellWidth = CANVAS_SIZE / gridWidth;
        cellHeight = CANVAS_SIZE / gridHeight;
        frames = frames.map(() => createEmptyGrid(gridWidth, gridHeight));
        currentFrameIndex = 0;
        renderFramesList();
        redrawCanvas();
        updateInfo();
        setStatus("Raster geändert.");
      }

      function presetChanged() {
        const [w, h] = presetSize.value.split("x").map(Number);
        customWidthInput.value = w;
        customHeightInput.value = h;
        resizeAllFrames(w, h);
      }

      function applyCustomSize() {
        const w = parseInt(customWidthInput.value, 10);
        const h = parseInt(customHeightInput.value, 10);
        if (Number.isNaN(w) || Number.isNaN(h)) {
          setStatus("Ungültiges Raster.");
          return;
        }
        if (w < MIN_SIZE || w > MAX_SIZE || h < MIN_SIZE || h > MAX_SIZE) {
          setStatus("Rastergröße nur von 5 bis 64 möglich.");
          return;
        }
        resizeAllFrames(w, h);
      }

      function setTool(tool) {
        currentTool = tool;
        isShapeDrawing = false;
        shapeStart = null;
        shapeCurrent = null;
        Object.values(toolButtons).forEach(btn => btn.classList.remove("active"));
        if (toolButtons[tool]) toolButtons[tool].classList.add("active");
        setStatus("Werkzeug: " + tool);
      }

      function toggleMirror() {
        mirrorMode = !mirrorMode;
        mirrorToggleBtn.classList.toggle("active", mirrorMode);
        setStatus(mirrorMode ? "Vertikale Spiegelung: an." : "Vertikale Spiegelung: aus.");
      }

      function clearCurrentFrame() {
        frames[currentFrameIndex] = createEmptyGrid(gridWidth, gridHeight);
        redrawCanvas();
        renderFramesList();
        setStatus("Aktueller Frame geleert.");
      }

      function saveImage() {
        const data = {
          width: gridWidth,
          height: gridHeight,
          frames,
        };
        const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `pixely-${gridWidth}x${gridHeight}.json`;
        a.click();
        URL.revokeObjectURL(url);
        setStatus("Projekt gespeichert (JSON).");
      }

      function loadImageFromFile(file) {
        const reader = new FileReader();
        reader.onload = e => {
          try {
            const data = JSON.parse(e.target.result);
            if (!data || typeof data.width !== "number" || typeof data.height !== "number" || !Array.isArray(data.frames)) {
              throw new Error("Formatfehler.");
            }
            if (data.width < MIN_SIZE || data.width > MAX_SIZE || data.height < MIN_SIZE || data.height > MAX_SIZE) {
              throw new Error("Unzulässige Rastergröße.");
            }
            gridWidth = data.width;
            gridHeight = data.height;
            cellWidth = CANVAS_SIZE / gridWidth;
            cellHeight = CANVAS_SIZE / gridHeight;
            frames = data.frames;
            currentFrameIndex = 0;

            customWidthInput.value = gridWidth;
            customHeightInput.value = gridHeight;
            const presetVal = `${gridWidth}x${gridHeight}`;
            if ([...presetSize.options].some(o => o.value === presetVal)) {
              presetSize.value = presetVal;
            }

            renderFramesList();
            redrawCanvas();
            updateInfo();
            setStatus("Projekt geladen.");
          } catch (err) {
            console.error(err);
            setStatus("Fehler beim Laden der Datei.");
          }
        };
        reader.readAsText(file);
      }

      function getCellFromEvent(ev) {
        const rect = canvas.getBoundingClientRect();
        const point =
          (ev.touches && ev.touches[0]) ||
          (ev.changedTouches && ev.changedTouches[0]) ||
          ev;
        const clientX = point.clientX;
        const clientY = point.clientY;
        const x = Math.floor(((clientX - rect.left) / rect.width) * gridWidth);
        const y = Math.floor(((clientY - rect.top) / rect.height) * gridHeight);
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return null;
        return { x, y };
      }

      function paintCellAt(grid, x, y, color) {
        if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) return;
        grid[y][x] = color;
      }

      function paintBrush(cell) {
        const grid = getCurrentGrid();
        const color = currentTool === "radierer" ? null : currentColor;
        const size = brushSize; // 1..4
        for (let dy = 0; dy < size; dy++) {
          for (let dx = 0; dx < size; dx++) {
            const nx = cell.x + dx;
            const ny = cell.y + dy;
            paintCellAt(grid, nx, ny, color);
            if (mirrorMode) {
              const mirrorStartX = gridWidth - size - cell.x + dx;
              const mx = mirrorStartX;
              const my = ny;
              paintCellAt(grid, mx, my, color);
            }
          }
        }
        redrawCanvas();
        renderFramesList();
      }

      // Rechteck: nur Umriss
      function drawRectShape(start, end, color, targetGrid) {
        const x1 = Math.min(start.x, end.x);
        const x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const y2 = Math.max(start.y, end.y);

        for (let x = x1; x <= x2; x++) {
          paintCellAt(targetGrid, x, y1, color);
          paintCellAt(targetGrid, x, y2, color);
        }
        for (let y = y1; y <= y2; y++) {
          paintCellAt(targetGrid, x1, y, color);
          paintCellAt(targetGrid, x2, y, color);
        }
      }

      // Kreis/Oval: nur Rand
      function drawCircleShape(start, end, color, targetGrid) {
        const x1 = Math.min(start.x, end.x);
        const x2 = Math.max(start.x, end.x);
        const y1 = Math.min(start.y, end.y);
        const y2 = Math.max(start.y, end.y);

        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const rx = (x2 - x1) / 2 || 0.5;
        const ry = (y2 - y1) / 2 || 0.5;

        for (let y = y1; y <= y2; y++) {
          for (let x = x1; x <= x2; x++) {
            const dx = (x - cx) / rx;
            const dy = (y - cy) / ry;
            const dist = dx * dx + dy * dy;
            if (dist <= 1.05 && dist >= 0.7) {
              paintCellAt(targetGrid, x, y, color);
            }
          }
        }
      }

      function previewShape(start, end) {
        const original = getCurrentGrid();
        const copy = original.map(row => row.slice());
        const color = currentColor;

        if (currentTool === "rechteck") {
          drawRectShape(start, end, color, copy);
          if (mirrorMode) {
            const w = gridWidth;
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawRectShape(ms, me, color, copy);
          }
        } else if (currentTool === "kreis") {
          drawCircleShape(start, end, color, copy);
          if (mirrorMode) {
            const w = gridWidth;
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawCircleShape(ms, me, color, copy);
          }
        }

        ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        drawGridToContext(ctx, copy, gridWidth, gridHeight, true);
      }

      function applyShape(start, end) {
        if (!start || !end) return;
        const grid = getCurrentGrid();
        const color = currentColor;

        if (currentTool === "rechteck") {
          drawRectShape(start, end, color, grid);
          if (mirrorMode) {
            const w = gridWidth;
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawRectShape(ms, me, color, grid);
          }
        } else if (currentTool === "kreis") {
          drawCircleShape(start, end, color, grid);
          if (mirrorMode) {
            const w = gridWidth;
            const ms = { x: w - 1 - start.x, y: start.y };
            const me = { x: w - 1 - end.x, y: end.y };
            drawCircleShape(ms, me, color, grid);
          }
        }

        redrawCanvas();
        renderFramesList();
      }

      function floodFill(startCell) {
        const grid = getCurrentGrid();
        const targetColor = grid[startCell.y][startCell.x] || null;
        const newColor = currentColor;
        if (targetColor === newColor) return;

        const stack = [startCell];
        const visited = new Set();
        function key(x, y) { return x + "," + y; }

        while (stack.length > 0) {
          const { x, y } = stack.pop();
          if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) continue;
          const k = key(x, y);
          if (visited.has(k)) continue;
          visited.add(k);

          const current = grid[y][x] || null;
          if (current !== targetColor) continue;

          grid[y][x] = newColor;

          stack.push({ x: x + 1, y });
          stack.push({ x: x - 1, y });
          stack.push({ x, y: y + 1 });
          stack.push({ x, y: y - 1 });
        }

        if (mirrorMode) {
          const mirrorStart = { x: gridWidth - 1 - startCell.x, y: startCell.y };
          const stack2 = [mirrorStart];
          const visited2 = new Set();
          const targetMirror = grid[mirrorStart.y][mirrorStart.x] || null;
          if (targetMirror !== newColor) {
            while (stack2.length > 0) {
              const { x, y } = stack2.pop();
              if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight) continue;
              const k2 = key(x, y);
              if (visited2.has(k2)) continue;
              visited2.add(k2);

              const current2 = grid[y][x] || null;
              if (current2 !== targetMirror) continue;

              grid[y][x] = newColor;

              stack2.push({ x: x + 1, y });
              stack2.push({ x: x - 1, y });
              stack2.push({ x, y: y + 1 });
              stack2.push({ x, y: y - 1 });
            }
          }
        }

        redrawCanvas();
        renderFramesList();
      }

      // Pointer
      function handlePointerDown(ev) {
        const cell = getCellFromEvent(ev);
        if (!cell) return;

        if (currentTool === "pinsel" || currentTool === "radierer") {
          isDrawing = true;
          paintBrush(cell);
        } else if (currentTool === "rechteck" || currentTool === "kreis") {
          isShapeDrawing = true;
          shapeStart = cell;
          shapeCurrent = cell;
          previewShape(shapeStart, shapeCurrent);
        } else if (currentTool === "fuellen") {
          floodFill(cell);
          setStatus("Fläche gefüllt.");
        }
      }

      function handlePointerMove(ev) {
        const cell = getCellFromEvent(ev);
        if (!cell) return;
        if (isDrawing && (currentTool === "pinsel" || currentTool === "radierer")) {
          paintBrush(cell);
        } else if (isShapeDrawing && shapeStart && (currentTool === "rechteck" || currentTool === "kreis")) {
          shapeCurrent = cell;
          previewShape(shapeStart, shapeCurrent);
        }
      }

      function handlePointerUp() {
        if (isDrawing) {
          isDrawing = false;
          return;
        }
        if (isShapeDrawing) {
          isShapeDrawing = false;
          if (shapeStart && shapeCurrent) {
            applyShape(shapeStart, shapeCurrent);
          } else {
            redrawCanvas();
          }
          shapeStart = null;
          shapeCurrent = null;
        }
      }

      function addEmptyFrameAfterCurrent() {
        const empty = createEmptyGrid(gridWidth, gridHeight);
        frames.splice(currentFrameIndex + 1, 0, empty);
        currentFrameIndex++;
        flashFrameActions(currentFrameIndex);
        renderFramesList();
        redrawCanvas();
        updateInfo();
        setStatus("Neues leeres Bild erstellt.");
      }

      function exportPNG() {
        const a = document.createElement("a");
        a.download = `pixely-${gridWidth}x${gridHeight}-frame${currentFrameIndex + 1}.png`;
        a.href = canvas.toDataURL("image/png");
        a.click();
        setStatus("PNG exportiert.");
      }

      function exportGIF() {
        if (gifExporting) return;
        if (typeof GIF === "undefined") {
          setStatus("GIF-Unterstützung nicht verfügbar.");
          return;
        }
        if (!frames.length) {
          setStatus("Keine Frames vorhanden.");
          return;
        }

        const delay = getGifDelayMs();
        const effectiveFps = Math.round(1000 / delay);
        const exportSize = Math.min(512, Math.max(gridWidth, gridHeight) * 32);
        gifExporting = true;
        exportGifBtn.disabled = true;
        exportGifBtn.textContent = "GIF wird erstellt …";

        let timeoutId = null;
        const restoreButton = (message) => {
          gifExporting = false;
          exportGifBtn.disabled = false;
          exportGifBtn.textContent = "GIF";
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          if (message) {
            setStatus(message);
          }
        };

        try {
          const gif = new GIF({
            workers: 1,
            quality: 10,
            width: exportSize,
            height: exportSize,
            workerScript: "https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js",
            repeat: 0,
          });

          frames.forEach(grid => {
            const off = document.createElement("canvas");
            off.width = exportSize;
            off.height = exportSize;
            const offCtx = off.getContext("2d");
            offCtx.clearRect(0, 0, exportSize, exportSize);
            drawGridToContext(offCtx, grid, gridWidth, gridHeight, false, exportSize);
            gif.addFrame(off, { delay, copy: true });
          });

          gif.on("progress", function (p) {
            setStatus(`GIF wird erstellt … ${Math.round(p * 100)}%`);
          });

          gif.on("finished", function (blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `pixely-${gridWidth}x${gridHeight}.gif`;
            a.click();
            URL.revokeObjectURL(url);
            restoreButton(`GIF exportiert (${effectiveFps} FPS).`);
          });

          gif.on("error", function () {
            restoreButton("GIF-Export fehlgeschlagen.");
          });

          timeoutId = setTimeout(() => {
            if (!gifExporting) return;
            gif.abort && gif.abort();
            restoreButton("GIF-Export fehlgeschlagen.");
          }, 15000);

          gif.render();
          setStatus("GIF wird erstellt …");
        } catch (err) {
          console.error(err);
          restoreButton("GIF-Export fehlgeschlagen.");
        }
      }

      // Events
      presetSize.addEventListener("change", presetChanged);
      applySizeBtn.addEventListener("click", applyCustomSize);

      newFrameBtn.addEventListener("click", addEmptyFrameAfterCurrent);

      brushBtn.addEventListener("click", () => setTool("pinsel"));
      eraserBtn.addEventListener("click", () => setTool("radierer"));
      rectBtn.addEventListener("click", () => setTool("rechteck"));
      circleBtn.addEventListener("click", () => setTool("kreis"));
      fillBtn.addEventListener("click", () => setTool("fuellen"));

      mirrorToggleBtn.addEventListener("click", toggleMirror);

      colorPicker.addEventListener("input", e => {
        currentColor = e.target.value;
      });

      brushSizeButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          brushSizeButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          brushSize = parseInt(btn.dataset.size, 10) || 1;
        });
      });

      saveBtn.addEventListener("click", saveImage);
      loadBtn.addEventListener("click", () => loadInput.click());
      loadInput.addEventListener("change", e => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        loadImageFromFile(file);
        loadInput.value = "";
      });

      clearBtn.addEventListener("click", clearCurrentFrame);

      exportPngBtn.addEventListener("click", exportPNG);
      exportGifBtn.addEventListener("click", exportGIF);
      gifFpsInput.addEventListener("input", () => {
        updateFpsLabel();
        if (previewPlaying) {
          startPreview();
        } else {
          refreshPreview();
        }
      });
      togglePreviewBtn.addEventListener("click", () => {
        if (previewPlaying) {
          stopPreview();
        } else {
          startPreview();
        }
      });
      restartPreviewBtn.addEventListener("click", () => {
        stopPreview();
        renderPreviewFrame(currentFrameIndex);
      });

      canvas.addEventListener("mousedown", handlePointerDown);
      canvas.addEventListener("mousemove", handlePointerMove);
      window.addEventListener("mouseup", handlePointerUp);

      canvas.addEventListener("touchstart", e => {
        e.preventDefault();
        handlePointerDown(e);
      }, { passive: false });
      canvas.addEventListener("touchmove", e => {
        e.preventDefault();
        handlePointerMove(e);
      }, { passive: false });
      canvas.addEventListener("touchend", e => {
        e.preventDefault();
        handlePointerUp();
      }, { passive: false });

      // Start
      initFrames();
      updateFpsLabel();
      setTool("pinsel");
      setStatus("Bereit zum Zeichnen.");
    })();
  </script>
</body>
</html>
